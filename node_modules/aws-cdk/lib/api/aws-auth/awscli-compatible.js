"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const util = require("util");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const promptly = require("promptly");
const logging_1 = require("../../logging");
const aws_sdk_inifile_1 = require("./aws-sdk-inifile");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * This is similar to the default credential provider chain created by the SDK
     * except:
     *
     * 1. Accepts profile argument in the constructor (the SDK must have it prepopulated
     *    in the environment).
     * 2. Conditionally checks EC2 credentials, because checking for EC2
     *    credentials on a non-EC2 machine may lead to long delays (in the best case)
     *    or an exception (in the worst case).
     * 3. Respects $AWS_SHARED_CREDENTIALS_FILE.
     * 4. Respects $AWS_DEFAULT_PROFILE in addition to $AWS_PROFILE.
     */
    static async credentialChain(options = {}) {
        var _a, _b;
        // To match AWS CLI behavior, if a profile is explicitly given using --profile,
        // we use that to the exclusion of everything else (note: this does not apply
        // to AWS_PROFILE, environment credentials still take precedence over AWS_PROFILE)
        if (options.profile) {
            await forceSdkToReadConfigIfPresent();
            const theProfile = options.profile;
            return new AWS.CredentialProviderChain([
                () => profileCredentials(theProfile),
                () => new AWS.ProcessCredentials({ profile: theProfile }),
            ]);
        }
        const implicitProfile = process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const sources = [
            () => new AWS.EnvironmentCredentials('AWS'),
            () => new AWS.EnvironmentCredentials('AMAZON'),
        ];
        if (await fs.pathExists(credentialsFileName())) {
            // Force reading the `config` file if it exists by setting the appropriate
            // environment variable.
            await forceSdkToReadConfigIfPresent();
            sources.push(() => profileCredentials(implicitProfile));
            sources.push(() => new AWS.ProcessCredentials({ profile: implicitProfile }));
        }
        if ((_a = options.containerCreds) !== null && _a !== void 0 ? _a : hasEcsCredentials()) {
            sources.push(() => new AWS.ECSCredentials());
        }
        else if ((_b = options.ec2instance) !== null && _b !== void 0 ? _b : await isEc2Instance()) {
            // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
            // run on EC2 boxes but the creds represent something different. Same behavior as
            // upstream code.
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
        return new AWS.CredentialProviderChain(sources);
        function profileCredentials(profileName) {
            return new aws_sdk_inifile_1.PatchedSharedIniFileCredentials({
                profile: profileName,
                filename: credentialsFileName(),
                httpOptions: options.httpOptions,
                tokenCodeFn,
            });
        }
    }
    /**
     * Return the default region in a CLI-compatible way
     *
     * Mostly copied from node_loader.js, but with the following differences to make it
     * AWS CLI compatible:
     *
     * 1. Takes a profile name as an argument (instead of forcing it to be taken from $AWS_PROFILE).
     *    This requires having made a copy of the SDK's `SharedIniFile` (the original
     *    does not take an argument).
     * 2. $AWS_DEFAULT_PROFILE and $AWS_DEFAULT_REGION are also respected.
     *
     * Lambda and CodeBuild set the $AWS_REGION variable.
     */
    static async region(options = {}) {
        var _a;
        const profile = options.profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        // Defaults inside constructor
        const toCheck = [
            { filename: credentialsFileName(), profile },
            { isConfig: true, filename: configFileName(), profile },
            { isConfig: true, filename: configFileName(), profile: 'default' },
        ];
        let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
        while (!region && toCheck.length > 0) {
            const opts = toCheck.shift();
            if (await fs.pathExists(opts.filename)) {
                const configFile = new sdk_ini_file_1.SharedIniFile(opts);
                const section = await configFile.getProfile(opts.profile);
                region = section === null || section === void 0 ? void 0 : section.region;
            }
        }
        if (!region && ((_a = options.ec2instance) !== null && _a !== void 0 ? _a : await isEc2Instance())) {
            logging_1.debug('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
            const imdsOptions = {
                httpOptions: { timeout: 1000, connectTimeout: 1000 }, maxRetries: 2,
            };
            const metadataService = new AWS.MetadataService(imdsOptions);
            let token;
            try {
                token = await getImdsV2Token(metadataService);
            }
            catch (e) {
                logging_1.debug(`No IMDSv2 token: ${e}`);
            }
            try {
                region = await getRegionFromImds(metadataService, token);
                logging_1.debug(`AWS region from IMDS: ${region}`);
            }
            catch (e) {
                logging_1.debug(`Unable to retrieve AWS region from IMDS: ${e}`);
            }
        }
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            region = 'us-east-1'; // This is what the AWS CLI does
            logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${region}'`);
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function isEc2Instance() {
    if (isEc2InstanceCache === undefined) {
        logging_1.debug("Determining if we're on an EC2 instance.");
        let instance = false;
        if (process.platform === 'win32') {
            // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
            const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
            // output looks like
            //  UUID
            //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
            const lines = result.stdout.toString().split('\n');
            instance = lines.some(x => matchesRegex(/^ec2/i, x));
        }
        else {
            // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
            const files = [
                // This recognizes the Xen hypervisor based instances (pre-5th gen)
                ['/sys/hypervisor/uuid', /^ec2/i],
                // This recognizes the new Hypervisor (5th-gen instances and higher)
                // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
                // Instead, sys_vendor contains something like 'Amazon EC2'.
                ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
            ];
            for (const [file, re] of files) {
                if (matchesRegex(re, readIfPossible(file))) {
                    instance = true;
                    break;
                }
            }
        }
        logging_1.debug(instance ? 'Looks like an EC2 instance.' : 'Does not look like an EC2 instance.');
        isEc2InstanceCache = instance;
    }
    return isEc2InstanceCache;
}
let isEc2InstanceCache = undefined;
/**
 * Attempts to get a Instance Metadata Service V2 token
 */
async function getImdsV2Token(metadataService) {
    logging_1.debug('Attempting to retrieve an IMDSv2 token.');
    return new Promise((resolve, reject) => {
        metadataService.request('/latest/api/token', {
            method: 'PUT',
            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '60' },
        }, (err, token) => {
            if (err) {
                reject(err);
            }
            else if (!token) {
                reject(new Error('IMDS did not return a token.'));
            }
            else {
                resolve(token);
            }
        });
    });
}
/**
 * Attempts to get the region from the Instance Metadata Service
 */
async function getRegionFromImds(metadataService, token) {
    logging_1.debug('Retrieving the AWS region from the IMDS.');
    let options = {};
    if (token) {
        options = { headers: { 'x-aws-ec2-metadata-token': token } };
    }
    return new Promise((resolve, reject) => {
        metadataService.request('/latest/dynamic/instance-identity/document', options, (err, instanceIdentityDocument) => {
            if (err) {
                reject(err);
            }
            else if (!instanceIdentityDocument) {
                reject(new Error('IMDS did not return an Instance Identity Document.'));
            }
            else {
                try {
                    resolve(JSON.parse(instanceIdentityDocument).region);
                }
                catch (e) {
                    reject(e);
                }
            }
        });
    });
}
function homeDir() {
    return process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
}
function credentialsFileName() {
    return process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(homeDir(), '.aws', 'credentials');
}
function configFileName() {
    return process.env.AWS_CONFIG_FILE || path.join(homeDir(), '.aws', 'config');
}
/**
 * Force the JS SDK to honor the ~/.aws/config file (and various settings therein)
 *
 * For example, there is just *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set,
 * or read credentials from that file.
 *
 * The SDK crashes if the variable is set but the file does not exist, so conditionally set it.
 */
async function forceSdkToReadConfigIfPresent() {
    if (await fs.pathExists(configFileName())) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn, cb) {
    logging_1.debug('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        logging_1.debug('Successfully got MFA token from user');
        cb(undefined, token);
    }
    catch (err) {
        logging_1.debug('Failed to get MFA token', err);
        cb(err);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsMkNBQXNDO0FBQ3RDLHVEQUFvRTtBQUNwRSxpREFBK0M7QUFFL0M7Ozs7Ozs7R0FPRztBQUNILE1BQWEsZ0JBQWdCO0lBQzNCOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxVQUFrQyxFQUFFOztRQUV0RSwrRUFBK0U7UUFDL0UsNkVBQTZFO1FBQzdFLGtGQUFrRjtRQUNsRixJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7WUFDbkIsTUFBTSw2QkFBNkIsRUFBRSxDQUFDO1lBQ3RDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7WUFDbkMsT0FBTyxJQUFJLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQztnQkFDckMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDO2dCQUNwQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQzthQUMxRCxDQUFDLENBQUM7U0FDSjtRQUVELE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLElBQUksU0FBUyxDQUFDO1FBRWhHLE1BQU0sT0FBTyxHQUFHO1lBQ2QsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDO1lBQzNDLEdBQUcsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FB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QzFFLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLEVBQUU7U0FDWixDQUFDLENBQUM7UUFDSCxlQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztRQUM5QyxFQUFFLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3RCO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDWixlQUFLLENBQUMseUJBQXlCLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdEMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ1Q7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFBhdGNoZWRTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgfSBmcm9tICcuL2F3cy1zZGstaW5pZmlsZSc7XG5pbXBvcnQgeyBTaGFyZWRJbmlGaWxlIH0gZnJvbSAnLi9zZGtfaW5pX2ZpbGUnO1xuXG4vKipcbiAqIEJlaGF2aW9ycyB0byBtYXRjaCBBV1MgQ0xJXG4gKlxuICogU2VlIHRoZXNlIGxpbmtzOlxuICpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3RvcGljL2NvbmZpZy12YXJzLmh0bWxcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3VzZXJndWlkZS9jbGktY29uZmlndXJlLWVudnZhcnMuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgQXdzQ2xpQ29tcGF0aWJsZSB7XG4gIC8qKlxuICAgKiBCdWlsZCBhbiBBV1MgQ0xJLWNvbXBhdGlibGUgY3JlZGVudGlhbCBjaGFpbiBwcm92aWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiBjcmVhdGVkIGJ5IHRoZSBTREtcbiAgICogZXhjZXB0OlxuICAgKlxuICAgKiAxLiBBY2NlcHRzIHByb2ZpbGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yICh0aGUgU0RLIG11c3QgaGF2ZSBpdCBwcmVwb3B1bGF0ZWRcbiAgICogICAgaW4gdGhlIGVudmlyb25tZW50KS5cbiAgICogMi4gQ29uZGl0aW9uYWxseSBjaGVja3MgRUMyIGNyZWRlbnRpYWxzLCBiZWNhdXNlIGNoZWNraW5nIGZvciBFQzJcbiAgICogICAgY3JlZGVudGlhbHMgb24gYSBub24tRUMyIG1hY2hpbmUgbWF5IGxlYWQgdG8gbG9uZyBkZWxheXMgKGluIHRoZSBiZXN0IGNhc2UpXG4gICAqICAgIG9yIGFuIGV4Y2VwdGlvbiAoaW4gdGhlIHdvcnN0IGNhc2UpLlxuICAgKiAzLiBSZXNwZWN0cyAkQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFLlxuICAgKiA0LiBSZXNwZWN0cyAkQVdTX0RFRkFVTFRfUFJPRklMRSBpbiBhZGRpdGlvbiB0byAkQVdTX1BST0ZJTEUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWRlbnRpYWxDaGFpbihvcHRpb25zOiBDcmVkZW50aWFsQ2hhaW5PcHRpb25zID0ge30pIHtcblxuICAgIC8vIFRvIG1hdGNoIEFXUyBDTEkgYmVoYXZpb3IsIGlmIGEgcHJvZmlsZSBpcyBleHBsaWNpdGx5IGdpdmVuIHVzaW5nIC0tcHJvZmlsZSxcbiAgICAvLyB3ZSB1c2UgdGhhdCB0byB0aGUgZXhjbHVzaW9uIG9mIGV2ZXJ5dGhpbmcgZWxzZSAobm90ZTogdGhpcyBkb2VzIG5vdCBhcHBseVxuICAgIC8vIHRvIEFXU19QUk9GSUxFLCBlbnZpcm9ubWVudCBjcmVkZW50aWFscyBzdGlsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBBV1NfUFJPRklMRSlcbiAgICBpZiAob3B0aW9ucy5wcm9maWxlKSB7XG4gICAgICBhd2FpdCBmb3JjZVNka1RvUmVhZENvbmZpZ0lmUHJlc2VudCgpO1xuICAgICAgY29uc3QgdGhlUHJvZmlsZSA9IG9wdGlvbnMucHJvZmlsZTtcbiAgICAgIHJldHVybiBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKFtcbiAgICAgICAgKCkgPT4gcHJvZmlsZUNyZWRlbnRpYWxzKHRoZVByb2ZpbGUpLFxuICAgICAgICAoKSA9PiBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscyh7IHByb2ZpbGU6IHRoZVByb2ZpbGUgfSksXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBsaWNpdFByb2ZpbGUgPSBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgIGNvbnN0IHNvdXJjZXMgPSBbXG4gICAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpLFxuICAgICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKSxcbiAgICBdO1xuXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoY3JlZGVudGlhbHNGaWxlTmFtZSgpKSkge1xuICAgICAgLy8gRm9yY2UgcmVhZGluZyB0aGUgYGNvbmZpZ2AgZmlsZSBpZiBpdCBleGlzdHMgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAgYXdhaXQgZm9yY2VTZGtUb1JlYWRDb25maWdJZlByZXNlbnQoKTtcbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBwcm9maWxlQ3JlZGVudGlhbHMoaW1wbGljaXRQcm9maWxlKSk7XG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMoeyBwcm9maWxlOiBpbXBsaWNpdFByb2ZpbGUgfSkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNvbnRhaW5lckNyZWRzID8/IGhhc0Vjc0NyZWRlbnRpYWxzKCkpIHtcbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCkpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lYzJpbnN0YW5jZSA/PyBhd2FpdCBpc0VjMkluc3RhbmNlKCkpIHtcbiAgICAgIC8vIGVsc2UgaWY6IGRvbid0IGdldCBFQzIgY3JlZHMgaWYgd2Ugc2hvdWxkIGhhdmUgZ290dGVuIEVDUyBjcmVkcy0tRUNTIGluc3RhbmNlcyBhbHNvXG4gICAgICAvLyBydW4gb24gRUMyIGJveGVzIGJ1dCB0aGUgY3JlZHMgcmVwcmVzZW50IHNvbWV0aGluZyBkaWZmZXJlbnQuIFNhbWUgYmVoYXZpb3IgYXNcbiAgICAgIC8vIHVwc3RyZWFtIGNvZGUuXG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKHNvdXJjZXMpO1xuXG4gICAgZnVuY3Rpb24gcHJvZmlsZUNyZWRlbnRpYWxzKHByb2ZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgUGF0Y2hlZFNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7XG4gICAgICAgIHByb2ZpbGU6IHByb2ZpbGVOYW1lLFxuICAgICAgICBmaWxlbmFtZTogY3JlZGVudGlhbHNGaWxlTmFtZSgpLFxuICAgICAgICBodHRwT3B0aW9uczogb3B0aW9ucy5odHRwT3B0aW9ucyxcbiAgICAgICAgdG9rZW5Db2RlRm4sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IHJlZ2lvbiBpbiBhIENMSS1jb21wYXRpYmxlIHdheVxuICAgKlxuICAgKiBNb3N0bHkgY29waWVkIGZyb20gbm9kZV9sb2FkZXIuanMsIGJ1dCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXMgdG8gbWFrZSBpdFxuICAgKiBBV1MgQ0xJIGNvbXBhdGlibGU6XG4gICAqXG4gICAqIDEuIFRha2VzIGEgcHJvZmlsZSBuYW1lIGFzIGFuIGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZvcmNpbmcgaXQgdG8gYmUgdGFrZW4gZnJvbSAkQVdTX1BST0ZJTEUpLlxuICAgKiAgICBUaGlzIHJlcXVpcmVzIGhhdmluZyBtYWRlIGEgY29weSBvZiB0aGUgU0RLJ3MgYFNoYXJlZEluaUZpbGVgICh0aGUgb3JpZ2luYWxcbiAgICogICAgZG9lcyBub3QgdGFrZSBhbiBhcmd1bWVudCkuXG4gICAqIDIuICRBV1NfREVGQVVMVF9QUk9GSUxFIGFuZCAkQVdTX0RFRkFVTFRfUkVHSU9OIGFyZSBhbHNvIHJlc3BlY3RlZC5cbiAgICpcbiAgICogTGFtYmRhIGFuZCBDb2RlQnVpbGQgc2V0IHRoZSAkQVdTX1JFR0lPTiB2YXJpYWJsZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVnaW9uKG9wdGlvbnM6IFJlZ2lvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcHJvZmlsZSA9IG9wdGlvbnMucHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgIC8vIERlZmF1bHRzIGluc2lkZSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IHRvQ2hlY2sgPSBbXG4gICAgICB7IGZpbGVuYW1lOiBjcmVkZW50aWFsc0ZpbGVOYW1lKCksIHByb2ZpbGUgfSxcbiAgICAgIHsgaXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBjb25maWdGaWxlTmFtZSgpLCBwcm9maWxlIH0sXG4gICAgICB7IGlzQ29uZmlnOiB0cnVlLCBmaWxlbmFtZTogY29uZmlnRmlsZU5hbWUoKSwgcHJvZmlsZTogJ2RlZmF1bHQnIH0sXG4gICAgXTtcblxuICAgIGxldCByZWdpb24gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9SRUdJT04gfHxcbiAgICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT047XG5cbiAgICB3aGlsZSAoIXJlZ2lvbiAmJiB0b0NoZWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB0b0NoZWNrLnNoaWZ0KCkhO1xuICAgICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMob3B0cy5maWxlbmFtZSkpIHtcbiAgICAgICAgY29uc3QgY29uZmlnRmlsZSA9IG5ldyBTaGFyZWRJbmlGaWxlKG9wdHMpO1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gYXdhaXQgY29uZmlnRmlsZS5nZXRQcm9maWxlKG9wdHMucHJvZmlsZSk7XG4gICAgICAgIHJlZ2lvbiA9IHNlY3Rpb24/LnJlZ2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlZ2lvbiAmJiAob3B0aW9ucy5lYzJpbnN0YW5jZSA/PyBhd2FpdCBpc0VjMkluc3RhbmNlKCkpKSB7XG4gICAgICBkZWJ1ZygnTG9va2luZyB1cCBBV1MgcmVnaW9uIGluIHRoZSBFQzIgSW5zdGFuY2UgTWV0YWRhdGEgU2VydmljZSAoSU1EUykuJyk7XG4gICAgICBjb25zdCBpbWRzT3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cE9wdGlvbnM6IHsgdGltZW91dDogMTAwMCwgY29ubmVjdFRpbWVvdXQ6IDEwMDAgfSwgbWF4UmV0cmllczogMixcbiAgICAgIH07XG4gICAgICBjb25zdCBtZXRhZGF0YVNlcnZpY2UgPSBuZXcgQVdTLk1ldGFkYXRhU2VydmljZShpbWRzT3B0aW9ucyk7XG5cbiAgICAgIGxldCB0b2tlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuID0gYXdhaXQgZ2V0SW1kc1YyVG9rZW4obWV0YWRhdGFTZXJ2aWNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoYE5vIElNRFN2MiB0b2tlbjogJHtlfWApO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZWdpb24gPSBhd2FpdCBnZXRSZWdpb25Gcm9tSW1kcyhtZXRhZGF0YVNlcnZpY2UsIHRva2VuKTtcbiAgICAgICAgZGVidWcoYEFXUyByZWdpb24gZnJvbSBJTURTOiAke3JlZ2lvbn1gKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoYFVuYWJsZSB0byByZXRyaWV2ZSBBV1MgcmVnaW9uIGZyb20gSU1EUzogJHtlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVnaW9uKSB7XG4gICAgICBjb25zdCB1c2VkUHJvZmlsZSA9ICFwcm9maWxlID8gJycgOiBgIChwcm9maWxlOiBcIiR7cHJvZmlsZX1cIilgO1xuICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7IC8vIFRoaXMgaXMgd2hhdCB0aGUgQVdTIENMSSBkb2VzXG4gICAgICBkZWJ1ZyhgVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGZyb20gZW52aXJvbm1lbnQgb3IgQVdTIGNvbmZpZ3VyYXRpb24ke3VzZWRQcm9maWxlfSwgZGVmYXVsdGluZyB0byAnJHtyZWdpb259J2ApO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBpdCBsb29rcyBsaWtlIHdlJ2xsIGhhdmUgRUNTIGNyZWRlbnRpYWxzIGF2YWlsYWJsZVxuICovXG5mdW5jdGlvbiBoYXNFY3NDcmVkZW50aWFscygpOiBib29sZWFuIHtcbiAgcmV0dXJuIChBV1MuRUNTQ3JlZGVudGlhbHMucHJvdG90eXBlIGFzIGFueSkuaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNFYzJJbnN0YW5jZSgpIHtcbiAgaWYgKGlzRWMySW5zdGFuY2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCJEZXRlcm1pbmluZyBpZiB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2UuXCIpO1xuICAgIGxldCBpbnN0YW5jZSA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9XaW5kb3dzR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsLnByb21pc2lmeShjaGlsZF9wcm9jZXNzLmV4ZWMpKCd3bWljIHBhdGggd2luMzJfY29tcHV0ZXJzeXN0ZW1wcm9kdWN0IGdldCB1dWlkJywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIC8vIG91dHB1dCBsb29rcyBsaWtlXG4gICAgICAvLyAgVVVJRFxuICAgICAgLy8gIEVDMkFFMTQ1LUQxREMtMTNCMi05NEVELTAxMjM0QUJDREVGXG4gICAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICBpbnN0YW5jZSA9IGxpbmVzLnNvbWUoeCA9PiBtYXRjaGVzUmVnZXgoL15lYzIvaSwgeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9Vc2VyR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgICBjb25zdCBmaWxlczogQXJyYXk8W3N0cmluZywgUmVnRXhwXT4gPSBbXG4gICAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgWGVuIGh5cGVydmlzb3IgYmFzZWQgaW5zdGFuY2VzIChwcmUtNXRoIGdlbilcbiAgICAgICAgWycvc3lzL2h5cGVydmlzb3IvdXVpZCcsIC9eZWMyL2ldLFxuXG4gICAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgbmV3IEh5cGVydmlzb3IgKDV0aC1nZW4gaW5zdGFuY2VzIGFuZCBoaWdoZXIpXG4gICAgICAgIC8vIENhbid0IHVzZSB0aGUgYWR2ZXJ0aXNlZCBmaWxlICcvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF91dWlkJyBiZWNhdXNlIGl0IHJlcXVpcmVzIHJvb3QgdG8gcmVhZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgc3lzX3ZlbmRvciBjb250YWlucyBzb21ldGhpbmcgbGlrZSAnQW1hem9uIEVDMicuXG4gICAgICAgIFsnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3N5c192ZW5kb3InLCAvZWMyL2ldLFxuICAgICAgXTtcbiAgICAgIGZvciAoY29uc3QgW2ZpbGUsIHJlXSBvZiBmaWxlcykge1xuICAgICAgICBpZiAobWF0Y2hlc1JlZ2V4KHJlLCByZWFkSWZQb3NzaWJsZShmaWxlKSkpIHtcbiAgICAgICAgICBpbnN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoaW5zdGFuY2UgPyAnTG9va3MgbGlrZSBhbiBFQzIgaW5zdGFuY2UuJyA6ICdEb2VzIG5vdCBsb29rIGxpa2UgYW4gRUMyIGluc3RhbmNlLicpO1xuICAgIGlzRWMySW5zdGFuY2VDYWNoZSA9IGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBpc0VjMkluc3RhbmNlQ2FjaGU7XG59XG5cblxubGV0IGlzRWMySW5zdGFuY2VDYWNoZTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBJbnN0YW5jZSBNZXRhZGF0YSBTZXJ2aWNlIFYyIHRva2VuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEltZHNWMlRva2VuKG1ldGFkYXRhU2VydmljZTogQVdTLk1ldGFkYXRhU2VydmljZSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGRlYnVnKCdBdHRlbXB0aW5nIHRvIHJldHJpZXZlIGFuIElNRFN2MiB0b2tlbi4nKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtZXRhZGF0YVNlcnZpY2UucmVxdWVzdChcbiAgICAgICcvbGF0ZXN0L2FwaS90b2tlbicsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbi10dGwtc2Vjb25kcyc6ICc2MCcgfSxcbiAgICAgIH0sXG4gICAgICAoZXJyOiBBV1MuQVdTRXJyb3IsIHRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0b2tlbikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0lNRFMgZGlkIG5vdCByZXR1cm4gYSB0b2tlbi4nKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgdGhlIHJlZ2lvbiBmcm9tIHRoZSBJbnN0YW5jZSBNZXRhZGF0YSBTZXJ2aWNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJlZ2lvbkZyb21JbWRzKG1ldGFkYXRhU2VydmljZTogQVdTLk1ldGFkYXRhU2VydmljZSwgdG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGRlYnVnKCdSZXRyaWV2aW5nIHRoZSBBV1MgcmVnaW9uIGZyb20gdGhlIElNRFMuJyk7XG4gIGxldCBvcHRpb25zOiB7IG1ldGhvZD86IHN0cmluZyB8IHVuZGVmaW5lZDsgaGVhZGVycz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nOyB9IHwgdW5kZWZpbmVkOyB9ID0ge307XG4gIGlmICh0b2tlbikge1xuICAgIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbic6IHRva2VuIH0gfTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1ldGFkYXRhU2VydmljZS5yZXF1ZXN0KFxuICAgICAgJy9sYXRlc3QvZHluYW1pYy9pbnN0YW5jZS1pZGVudGl0eS9kb2N1bWVudCcsXG4gICAgICBvcHRpb25zLFxuICAgICAgKGVycjogQVdTLkFXU0Vycm9yLCBpbnN0YW5jZUlkZW50aXR5RG9jdW1lbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlSWRlbnRpdHlEb2N1bWVudCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0lNRFMgZGlkIG5vdCByZXR1cm4gYW4gSW5zdGFuY2UgSWRlbnRpdHkgRG9jdW1lbnQuJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoaW5zdGFuY2VJZGVudGl0eURvY3VtZW50KS5yZWdpb24pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaG9tZURpcigpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkhPTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEVcbiAgICB8fCAocHJvY2Vzcy5lbnYuSE9NRVBBVEggPyAoKHByb2Nlc3MuZW52LkhPTUVEUklWRSB8fCAnQzovJykgKyBwcm9jZXNzLmVudi5IT01FUEFUSCkgOiBudWxsKSB8fCBvcy5ob21lZGlyKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWRlbnRpYWxzRmlsZU5hbWUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfHwgcGF0aC5qb2luKGhvbWVEaXIoKSwgJy5hd3MnLCAnY3JlZGVudGlhbHMnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRmlsZU5hbWUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEUgfHwgcGF0aC5qb2luKGhvbWVEaXIoKSwgJy5hd3MnLCAnY29uZmlnJyk7XG59XG5cbi8qKlxuICogRm9yY2UgdGhlIEpTIFNESyB0byBob25vciB0aGUgfi8uYXdzL2NvbmZpZyBmaWxlIChhbmQgdmFyaW91cyBzZXR0aW5ncyB0aGVyZWluKVxuICpcbiAqIEZvciBleGFtcGxlLCB0aGVyZSBpcyBqdXN0ICpOTyogd2F5IHRvIGRvIEFzc3VtZVJvbGUgY3JlZGVudGlhbHMgYXMgbG9uZyBhcyBBV1NfU0RLX0xPQURfQ09ORklHIGlzIG5vdCBzZXQsXG4gKiBvciByZWFkIGNyZWRlbnRpYWxzIGZyb20gdGhhdCBmaWxlLlxuICpcbiAqIFRoZSBTREsgY3Jhc2hlcyBpZiB0aGUgdmFyaWFibGUgaXMgc2V0IGJ1dCB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCwgc28gY29uZGl0aW9uYWxseSBzZXQgaXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZvcmNlU2RrVG9SZWFkQ29uZmlnSWZQcmVzZW50KCkge1xuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhjb25maWdGaWxlTmFtZSgpKSkge1xuICAgIHByb2Nlc3MuZW52LkFXU19TREtfTE9BRF9DT05GSUcgPSAnMSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1JlZ2V4KHJlOiBSZWdFeHAsIHM6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gcyAhPT0gdW5kZWZpbmVkICYmIHJlLmV4ZWMocykgIT09IG51bGw7XG59XG5cbi8qKlxuICogUmVhZCBhIGZpbGUgaWYgaXQgZXhpc3RzLCBvciByZXR1cm4gdW5kZWZpbmVkXG4gKlxuICogTm90IGFzeW5jIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcmVhZElmUG9zc2libGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5wYXRoRXhpc3RzU3luYyhmaWxlbmFtZSkpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhlKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlZGVudGlhbENoYWluT3B0aW9ucyB7XG4gIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVjMmluc3RhbmNlPzogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY29udGFpbmVyQ3JlZHM/OiBib29sZWFuO1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IEFXUy5IVFRQT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpb25PcHRpb25zIHtcbiAgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcbiAgcmVhZG9ubHkgZWMyaW5zdGFuY2U/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFzayB1c2VyIGZvciBNRkEgdG9rZW4gZm9yIGdpdmVuIHNlcmlhbFxuICpcbiAqIFJlc3VsdCBpcyBzZW5kIHRvIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBTREsgdG8gYXV0aG9yaXplIHRoZSByZXF1ZXN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRva2VuQ29kZUZuKHNlcmlhbEFybjogc3RyaW5nLCBjYjogKGVycj86IEVycm9yLCB0b2tlbj86IHN0cmluZykgPT4gdm9pZCk6IFByb21pc2U8dm9pZD4ge1xuICBkZWJ1ZygnUmVxdWlyZSBNRkEgdG9rZW4gZm9yIHNlcmlhbCBBUk4nLCBzZXJpYWxBcm4pO1xuICB0cnkge1xuICAgIGNvbnN0IHRva2VuOiBzdHJpbmcgPSBhd2FpdCBwcm9tcHRseS5wcm9tcHQoYE1GQSB0b2tlbiBmb3IgJHtzZXJpYWxBcm59OiBgLCB7XG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgfSk7XG4gICAgZGVidWcoJ1N1Y2Nlc3NmdWxseSBnb3QgTUZBIHRva2VuIGZyb20gdXNlcicpO1xuICAgIGNiKHVuZGVmaW5lZCwgdG9rZW4pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWJ1ZygnRmFpbGVkIHRvIGdldCBNRkEgdG9rZW4nLCBlcnIpO1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuIl19